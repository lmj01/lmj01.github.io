
# Three.js

> review源代码过程中的感受

## 技术细节
### version
很多资源有个version，也就是一个int，表示使用的资源，只要有属性变更就表示需要更新的资源了。与C/C++的相比，需要一个标记的类似的作用。

## Shadow Mon Sep 09 2019 15:33:41

问题产生于TransformControls鼠标缩放后，一些物体因光线影响，物体并没有改变，改变的仅是camera的position。因为使用的是DirectionalLight

这里存在的是shader的过程，摄像机太近，产生阴影效果，就像人眼近距离看物体一样，大部分被遮挡，目前就像游戏中的逻辑，FPS的方案，而现在需要的是像三维编辑软件那样！这是概念不清晰的问题！


## 粒度与封装 Sun Jun 30 2019 11:02:07
越来越感受到这个问题了！从开始学编程时，都是做helloworld这样的项目，使用任何SD看时也使用别人的demo来修改添加砖瓦。
这就是没有从软件工程来考虑，没有写库的思维，更没有性能优化一说，这是目前我所工作中遇到的都是一年又一年的经验，重复的，无创造的软件开发，也就是代码民工。
粒度越细，才能从中取进行优化，才能取做更自由的组合，而非受限于SDK的接口，说做不出什么东西来，的确，如果全是demo级别的东西，你怎么能做出更优秀的，与众不同的产品呢？
粒度越细，那些函数的调用都可跟踪，这样把抽象的数据模型（需要的数据封装成自己的对象）当作内部来使用，尽量减少调用底层的次数，尽量把能处理的都放在自己内部来处理。这就是一个优秀库的核心价值。
封装，为什么要有独自的封装呢？因为你使用的是你自己的数据模型，而底层的灵活与自由度对你来说是一个负担，因为底层相信你能处理好。而大部分人是没法处理好底层的，概念都常常把握不稳，这就是软硬件中分层概念非常常见，也是必然的选择的原因。国外很多软件基本都追随这个思路来，而国内目前的环境都是大家还在考虑怎么活下去，根本不会考虑这些问题。也认为这些问题现阶段不必要，到最后，也是活得不如人意的。

## shader Fri Jul 12 2019 00:05:37
shader的大量重复函数，被解耦了，使用大量的宏来区别各种光照模型的差异
因为本身就是WebGL和WebGL2标准，虽然有点语法上的差异，通过使用字符串的拼接和替换形式来完成了各种代码的复用，最好形成了shader对应着相应的版本，这兼容模式就是在代码构建时完成shader的再构造。
大量的chunk代码很难一下子理解，对于不熟悉的库的人就只能写所有被人可以看到的源码了，而要保持代码的安全性和门槛，就需要去理解大量的chunk及光照模型

## 关于ID Mon Jul 29 2019 13:58:05
在render中，每次的更新material的id或类似的id都是变化的，与上次不同，是如何来保证增加后值不会溢出了。Javascript的Number是一个64位的float类型，应该足够使用了。这里不需要考虑回收ID的用法。