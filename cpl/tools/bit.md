# bit technical

有关位运算的知识，二进制表示的数字值

## 正负数

为表示正负数，使用了二进制补码机制，最高位为符号位，以一个字节为例：

```c
0000 0011 // +3    			
1000 0011 // -3 需要进行补码处理，如果不进行补码处理，就存在两个0：-0和+0
// 编码先减一再取反，符号位不变 -> 1000 0010 -> 1111 1101 
// 解码先取反再加一，符号位不变 -> 1000 0010 -> 1000 0011 
```

### 运算符
- 取反 ~(1001 0010)=(0110 1101)
- 与 (1001 0011)&(0011 1101)=(0001 0001)
- 位或 (1001 0011)|(0011 1101)=(1011 1111)
- 位异或 (1001 0011)^(0011 1101)=(1010 1110)
- 左移
  - 无符号数 (0000 0011)<<2=(0000 1100)
  - 有符号数 (0010 0011)<<2=(1000 1100),由正数变成负数
- 右移
  - 无符号数(0000 1100)>>2=(0000 0011)
  - 有符号数
    - 算术右移(1000 1010)>>2=(1110 0010)，左端以1填充
    - 逻辑右移(1000 1010)>>2=(0010 0010)，左端以0填充

### 表示集合

这里以int为32位为例，表示有32个元素的集合

```c
// A=1011,则集合位{0,1,3}
// A, B
#define ALL_BITS 0xffff
A|B // 集合的并
A&B // 集合的交
A&~B // 集合的差A-B
ALL_BITS^A // A的补集
A|=1<<bit // 添加特定元素
A^=1<<bit // 清除特定元素
A&=1<<bit // 取特定元素
A&(1<<bit)==0 // 判断是否存在
```



## 实例

### 判断一个数为2的N次方

```c
bool isPowOfTwo(int n){
    return 0 == (n & (n-1));
}
```



