<!DOCTYPE html>
<html>
<head>
<title>PBR3ed</title>
<script src="./html.config.js" defer></script>
<script src="./mathjax.config.js" defer></script>
</script>
</head>
<body>
    <div class="container-xl">
        <h1>content</h1>
        <div class="d-flex flex-column">
            <ol>
                <li><a href="#section5">Color And Radiometry</a></li>
                <li><a href="#section7">Samping and Reconstruction</a></li>
            </ol>
        </div>
        <div>
            <h4 id="section5">5. Color And Radiometry</h4>
            <p>可见光的波段380到780，400以下是bluish， 550是greens，大于650是reds</p>
            <p>spectral power distribution(SPD)频谱功率分布</p>
            <ul>
                <li><em>flux</em></li>
                <li><em>intensity</em></li>
                <li><em>irradiance</em></li>
                <li><em>radiance</em></li>
            </ul>
            <div>
                <h5>5.2.1 XYZ Color</h5>
                <p>A remarkable property of the human visual system makes it possible to represent colors for human perception with just three floating-point numbers. The tristimulus theory of color perception says that all visible SPDs can be accurately represented for human observers with three values, \( \mathcal{x}_{\lambda} \), , \( \mathcal{y}_{\lambda} \) and \( \mathcal{z}_{\lambda} \). Given an emissive SPD , these values are computed by integrating its product with the spectral matching curves \(X(\lambda)\), \(Y(\lambda)\), and \(Z(\lambda)\):</p>
            </div>
            <div>
                <h5>5.4 Radiometry辐射度学</h5>
                <p>radiometry提供了一系列的主意和数学工具来描述light的传播和反射，它是形成渲染算法的基础，radiometry首先引入图形学不是因为物理光的原则，而是作为空间粒子的抽象光属性。</p>
                <p>Radiative transfer辐射传输是radiant energy辐射能量传输的现象研究。辐射传输基于辐射原理和几何光学水平的操作，光的微波属性用来描述光与物体交互时比光的波长要长的。辐射度学与Maxwell经典方程描述了电子场域</p>
                <p>在pbrt中，假设几何光学最需要</p>
                <p><em>Energy能量</em>，以joules\((\mathcal{J})\)焦耳为单位。光源发射光子photons，每个光子以特定波长并携带一定的能量。辐射量学就是以不同方式测量光子。一个光子在特定波长\(\lambda\)携带的能量是</p>
                <p>$$\mathcal{Q}=\frac{hc}{\lambda}$$</p>
                <p>其中的c是光速，h是普朗克常数</p>
                <p><em>Flux通量</em>，Radiant flux，是穿过表面surface或区域region of space的单位时间内的总能量</p>
                <p>$$\Phi=\lim\limits_{{\Delta}t \to 0}\frac{{\Delta}Q}{{\Delta}t}=\frac{dQ}{dt}$$</p>
            </div>
        </div>
        <div>
            <h4 id="section7">7. Samping and Reconstruction</h4>
            <div>
                <h5></h5>
                <p></p>
            </div>
            <div>
                <h5>7.2.1 Evaluating Samping Patterns: Discrepancy</h5>
                <p>Fourier analysis gave us one way of evaluating the quality of a 2D sampling pattern, but it took us only as far as being able to quantify the improvement from adding more evenly spaced samples in terms of the band-limited frequencies that could be represented</p>
                <p>Outside of Fourier analysis, mathematicians have developed a concept called discrepancy that can be used to evaluate the quality of a pattern of -dimensional sample positions. </p>
                <blockquote cite="https://developer.nvidia.com/rtx/dlss">
                    Nvidia应用深度学习研究副总裁Bryan Catanzaro表示，原生分辨率不再是游戏中实现最大图形保真度的最佳解决方案，游戏图形行业在未来正朝着更加依赖AI图像重建和基于AI的图形渲染的方向发展。
                    DLSS 全称Deep Learning Super Sampling（深度学习超级采样）。它是一种视频渲染技术，Nvidia 使用神经网络超级计算机，通过机器深度学习来训练其人工智能，具体方式是不断地让人工智能自动比对超高分辨率静态图像（SSAA超级采样抗锯齿版本）和低分辨率图像之间的差异，使人工智能有能力推理出把图像从较低的分辨率提升到较高的分辨率的方法。也就是说，这项技术以较低的分辨率渲染图形以保持较高的性能，然后应用各种效果输出高分辨率图像的整体效果。
                </blockquote>
                <p></p>
            </div>
            <div>
                <h5>7.3 Stratified Sampling</h5>
                <p>The first Sampler implementation that we will introduce subdivides pixel areas into rectangular regions and generates a single sample inside each region. These regions are commonly called strata, and this sampler is called the StratifiedSampler.</p>
                <blockquote cite="https://developer.nvidia.com/rtx/dlss">
                    分层抽样（Stratified Sampling）
                </blockquote>
                <p></p>
            </div>
            <div>
                <h5>7.4 The Halton Sampler</h5>
                <p>The first Sampler implementation that we will introduce subdivides pixel areas into rectangular regions and generates a single sample inside each region. These regions are commonly called strata, and this sampler is called the StratifiedSampler.</p>
                <blockquote cite="https://developer.nvidia.com/rtx/dlss">
                    分层抽样（Stratified Sampling）
                </blockquote>
                <p>
                    The bits of an integer quantity can be efficiently reversed with a series of logical bit operations. The first line of the ReverseBits32() function, which reverses the bits of a 32-bit integer, swaps the lower 16 bits with the upper 16 bits of the value. The next line simultaneously swaps the first 8 bits of the result with the second 8 bits and the third 8 bits with the fourth. This process continues until the last line, which swaps adjacent bits. To understand this code, it’s helpful to write out the binary values of the various hexadecimal constants. For example, 0xff00ff00 is 11111111000000001111111100000000 in binary; it’s easy to see that a bitwise OR with this value masks off the first and third 8-bit quantities.                     
                    <pre>
                        inline uint32_t ReverseBits32(uint32_t n) {
                            n = (n << 16) | (n >> 16);
                            n = ((n & 0x00ff00ff) << 8) | ((n & 0xff00ff00) >> 8);
                            n = ((n & 0x0f0f0f0f) << 4) | ((n & 0xf0f0f0f0) >> 4);
                            n = ((n & 0x33333333) << 2) | ((n & 0xcccccccc) >> 2);
                            n = ((n & 0x55555555) << 1) | ((n & 0xaaaaaaaa) >> 1);
                            return n;
                        }
                        inline uint64_t ReverseBits64(uint64_t n) {
                            uint64_t n0 = ReverseBits32((uint32_t)n);
                            uint64_t n1 = ReverseBits32((uint32_t)(n >> 32));
                            return (n0 << 32) | n1;
                        }
                    </pre>
                </p>
                <p></p>
            </div>            
            <div>
                <h5>7.5 (0,2)-Sequence Sampler</h5>
                <p>
                    7.5.1 Sampling with Generator Matrics
                    <pre>
                        inline uint32_t GrayCode(uint32_t n) {
                            return (n >> 1) ^ n;
                        }
                    </pre>
                </p>
            </div>            
            <div>
                <h5>7.8.1 Filter Functions</h5>
                <p>
                    box filter, one of the most commonly used filters in graphics,
                    when filtering and reconstruction aren’t addressed explicitly, the box filter is the de facto result
                    The box filter equally weights all samples within a square region of the image. Although computationally efficient, it’s just about the worst filter possible.
                </p>
                <p>
                    triangle filter, gives slightly better results than the box: the weight falls off linearly from the filter center over the square extent of the filter. 
                </p>
                <p>
                    Gaussian Filter, Unlike the box and triangle filters, the Gaussian filter gives a reasonably good result in practice. This filter applies a Gaussian bump that is centered at the pixel and radially symmetric around it. The Gaussian’s value at the end of its extent is subtracted from the filter value, in order to make the filter go to 0 at its limit
                </p>
            </div>
        </div>
    </div>
</body>
</html>